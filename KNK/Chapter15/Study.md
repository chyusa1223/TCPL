## Chapter 15. Writing Large Programs

### 15.1 Source files

   - 프로그램을 여러 소스파일로 분할하는데는 여러 장점이 존재한다.

   1. 비슷한 함수나 변수들을 한 파일에 배치함으로써 프로그램의 구조를 명료하게 할 수 있다.
   2. 각각의 파일은 개별적으로 컴파일 될 수 있으므로, 프로그램의 규모가 매우 크고 자주 바뀌게 된다면 상당한 시간을 절약할 수 있다.
   3. 잘 그룹화된 소스코드는 다른 프로그램에서도 재활용이 가능하다.

### 15.2 Header Files

   - C언어에서 다른 파일에 있는 함수나 변수를 참조 가능한 이유는 #include 때문이다.
   - #include는 전처리과정에서 특정 파일을 열고 해당하는 내용을 현재 파일에 포함시킨다.

   - #include에는 두 가지 형태가 존재한다.

     1. #include <filename>
     2. #include "filename"

   - 첫 번째 형태는 C언어 자체의 라이브러리를 활용할 때 사용하고, 두 번째 형태는 모든 다른 헤더 파일을 이용할때 사용한다.
   - 대부분의 컴파일러에서는 <filename> 의 형태로 선언된 경우, /usr/include와 같은 경로에서 시스템 헤더 파일을 찾는다.
   - "filename"으로 선언된 경우에는 현재 디렉토리를 우선으로 검색한다.

   - filename에 해당하는 부분에는 파일의 위에 대한 정보를 포함시키기 위하여 디렉토리 경로를 포함하여 작성할 수 있다. ex) "/cprogs/utils.h"

   - "filename"의 형태로 작성된 경우에는 이는 문자열 상수처럼 보일 수 있지만, 전처리기는 이를 그런식으로 처리하지 않는다. 이는 다행스럽게도 "\cprogs\include\utils.h"와 같은 예제에서 \c는 escape sequence로 해석되지 않는 결과를 가져온다.

   - #include의 마지막 형태는 #include tokens이다. 전처리기는 토큰에 해당되는 매크로를 찾고 이를 치환한다. 매크로로 인해 치환된 이후에는 위에 언급했던 두 형태중 하나를 만족해야 한다.

   - 대부분의 프로그램은 여러 소스파일에서 동시에 사용될 타입이나 매크로를 가지고 있다. 이러한 정의들을 헤더 파일에 포함함으로서 각각의 소스파일에 이를 복사할 필요가 없어진다.

   - 추가적으로 이는 프로그램의 수정을 용이하게 한다.

   - 만약 소스파일이 함수 f에 대한 정의를 다른 파일에 가지고 있다고 가정해보자. 함수 f에 대한 정의 없이 이를 호출하는 것은 매우 위험하다. 프로토타입 없이는 컴파일러는 f의 리턴 타입을 int로 가정하고, 함수 호출의 인수또한 default argument promotion을 통해 변화시킬 것이다.

   - 이는 함수 원형에 대한 선언을 각각의 소스파일에 포함시키므로서 해소할 수 있다. 그러나 이는 유지보수 측면에서는 최악의 선택이 될 것이다.

   - 따라서 이 대신, 헤더파일을 소스파일에 포함시키므로서 함수원형을 포함하면서도 유지보수의 문제를 해결할 수 있다.

   - 변수 또한 함수와 비슷한 방법으로 사용될 수 있다. 변수의 경우에는 extern 키워드를 사용하여 선언하게 되면 ex) extern int i; 이는 변수를 선언하지만, i를 위한 공간을 할당하지는 않는다. extern 키워드는 컴파일러에게 해당 변수가 다른 곳에서 정의되었음을 알려준다.

   - extern 키워드는 어떠한 형태의 변수와도 사용이 가능하다. 위에 말한대로 extern 키워드가 붙은 변수는 정의하지 않기 때문에 ex) extern int a[]와 같이 길이 정보 없이 배열을 선언하는 것 또한 가능하다.

   - 만약 같은 이름을 가지는 변수가 다른 데이터 타입으로 다른 파일에 선언되어있다면 컴파일러는 이를 확인할 수 없으며 예상치 못한 결과를 가져오게 된다. 이러한 불일관성을 위해 여러 곳에서 사용되는 변수는 주로 헤더 파일에 포함된다. 해당 헤더파일은 변수에 대한 정의를 가지는 소스파일에 포함 되어 일치하는지 확인된다.

   - 많은 c언어 프로그램에서 공유 변수는 흔히 사용되어 왔지만, 최대한 배제하는 것이 바람직하다.

   - Header file안에 #include가 포함되는 것이 가능하다. 예를 들어 bool 타입을 리턴하는 함수의 원형을 작성하고자 한다면 #include <stdbool.h>를 포함하여야할 것이다. 

   - 헤더 파일을 중복되어서 포함될 경우에 컴파일 에러를 발생 시킬 수 있다. 만약 헤더 파일에 매크로, 함수 원형만 있다면 상관이 없겠지만 타입 정의와 같은 코드가 중복되어 나온다면 에러가 발생하게된다. 우리는 이러한 현상을 방지하기 위해 #ifndef등을 사용한다. 만약 파일이 처음으로 포함될때 특정 매크로를 정의하게 한다면 이후에는 같은 헤더파일이 중복되어 포함되는 일은 없을 것이다.

   - 헤더 파일에 #error또한 사용된다. 이는 헤더 파일이 포함되지 않아야 할 경우에 사용된다.

     ex) #ifndef __STDC__
     	 #error This header requires a Standard C compiler
	 #endif 

### 15.4 Building a Multiple-File Programs

   - 컴파일

   - 한 프로그램에 포함되는 각각의 소스파일들은 개별적으로 컴파일 된다. 헤더 파일들은 별도로 컴파일 되지 않으며 헤더파일을 가지고 있는 소스파일을 컴파일 할 때 자동적으로 포함되어 컴파일 된다. 컴파일의 결과로 컴파일러는 object 파일을 생성한다.

   - Linking

   - 링커는 컴파일의 결과물인 오브젝트 파일들을 라이브러리 함수들과 합쳐서 결합하여 executable 파일을 만들어낸다. 링커는 컴파일러가 남겨둔 외부 참조를 해결해야할 책임이 있다.

   - Makefile

   - 프로그램의 규모가 커질 수록 프로그램을 다시 빌드하는데 있어서 많은 시간이 소요된다. 이러한 작업을 쉽게하기 위하여 Unix에서는 makeFile이 존재한다. makefile에서는 파일명만 나열하는 것이 아니라 파일간의 연관관계 또한 포함하게 된다. 해당 makefile은 한 번 만들어 놓게되면, 이후 프로그램을 빌드할 때 계속 사용이 가능하다. make는 특정 파일이 최신 버전인지를 확인하여 해당 소스파일만 다시 컴파일하여 빌드하게 된다.

### Errors During Linking

   - 링커에 의해 발생하는 에러는 대부분 크게 두 가지로 나뉜다. 첫 번째는 "undefined symbol"이고 두 번째는 "undefined reference"이다. 

   - 함수나 변수명이 잘못되어 있을 경우 
   - 해당 파일이 누락되어 있는 경우
   - 해당 라이브러리 파일을 찾을 수 없는 경우
     ex) 대표적인 예로 UNIX에서 math.h을 사용하려고 하는 경우 -lm옵션을 활성화해서 링커에게 시스템 파일을 검색하도록 해야한다. 

### Rebuilding a Program

   - 만약 한 파일만 수정 되었을 경우에는, 해당 파일을 재컴파일하고 링킹해주면 된다.
   - 만약 헤더파일이 수정 되었을 경우에는, 해당 해더 파일을 가지는 모든 소스 파일을 다시 컴파일 해야한다. 이후 당연히 링킹도 다시 진행해야한다. 
   - Makefile을 사용하게 되면 수정후 build하는 과정에서 make가 이를 판단하여 자동으로 필요한 부분만 재 컴파일하여 링킹해주게 된다.

   - 몇몇 컴파일러는 프로그램의 컴파일 과정에서 매크로를 정의하고 값을 지정하는 방법을 지원한다. 예를 들어 gcc에서는 gcc -DDEBUG=1 foo.c로 실행하게 되면 이는 #define DEBUG 1로 선언한 것과 동일하다. 이러한 방법은 프로그램의 파일을 수정하지 않고 매크로를 값을 쉽게 바꿀 수 있게 해준다.  

### Q&A

   -  #include에 소스코드를 사용하는 것 자체는 가능하나 이를 최대한 배제하는 것이 좋다. 예를 들어 보자. foo.c라는 파일 자체를 #include를 활용하여 bar.c baz.c 두 파일에 포함시킨다고 가정하자. 이러한 경우에 컴파일을 정상적으로 진행되겠지만 후에 링커는 같은 오브젝트 코드가 중복 됨을 발견하게 될 것이다. 또한 foo.c 자체는 컴파일 되지 않아야 한다. 왜냐하면 #include는 기본적으로 복사 붙여넣기로 수행됨으로 이 또한 오브젝트 파일이 중복 될 것이기 때문이다. 따라서 헤더파일을 이용하는 것이 바람직하다.

   - #Include에서 파일을 검색하는 규칙은?
   - 엄밀히 얘기해서 존재하지 않는다. 이는 컴파일러의 구현에 달려있다. 이는 각 운영체제 별로 파일 시스템을 표기혹은 구현하는 방식이 다르기 때문이다. 심지어 #include <filename>에 filename은 실제로 파일명일 필요 또한 없다. 이 또한 컴파일러의 구현에 따라서 다르게 활용될 수 있다.

   - 여러개의 작은 헤더 파일을 사용하는 이유?
   - 큰 하나의 헤더파일이 가독성을 떨어뜨리기 때문에, 헤더 파일의 수정이 전체 프로그램 파일의 재 컴파일로 이어지기 때문에

   - 컴파일과 링킹은 C에서 완전히 분리되어 있으며, 헤더 파일은 컴파일러에게 정보를 제공하기 위한 수단으로 링커에는 아무런 영향이 없다. foo.c에 있는 함수를 사용하려면 foo.c를 컴파일 해야하고, 링커가 foo.c의 오브젝트 파일을 찾을 수 있어야한다.

   - #include <stdio.h>를 사용하면 stdio.h안에 존재하는 모든 함수들이 프로그램에 linking 되는지?
   - 그렇지 않다. 일단 #include는 전처리기에서 실행된다. 대부분의 링커들을 실제로 프로그램이 사용하는 함수만 프로그램에 포함한다. 

   - #include <stdio.h>는 중복해서 포함되어도 error를 띄우지 않는데 어떻게 된것인지?
   - 이는 stdio.h내에 매크로 정의를 통해서 중복되어 포함되지 않도록 구현되어 있기 때문이며 이러한 처리가 없으면 마찬가지로 에러가 발생한다. 